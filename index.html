<button id="start-button">¬°COMENZAR!</button>

<div id="canvas-container"></div>

<div id="ui-overlay">
    <div id="title">
        <h1>ABEL COELLO</h1>
        <p>Portfolio Interactivo 3D</p>
    </div>

    <div id="controls-info">
        <h3>üéÆ CONTROLES</h3>
        <p>Toca IZQUIERDA/DERECHA para girar</p>
        <p>Inclina el iPad para m√°s control</p>
    </div>

    <div id="speed-meter">
        <h4>VELOCIDAD</h4>
        <div id="speed-value">0 km/h</div>
    </div>

    <div id="works-counter">
        <h4>OBRAS DESCUBIERTAS</h4>
        <div id="works-value">0 / 6</div>
    </div>
</div>

<div class="joystick-zone" id="left-zone"></div>
<div class="joystick-zone" id="right-zone"></div>

<div id="game-over">
    <h2>¬°FIN DEL RECORRIDO!</h2>
    <p>Has descubierto <span id="final-count">0</span> obras</p>
    <button class="restart-button" onclick="location.reload()">VOLVER A EMPEZAR</button>
</div>

<!-- Popups para cada obra -->
<div class="popup-overlay" id="popup-1">
    <div class="popup-content">
        <h2>üé® Proyecto Arquitect√≥nico</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px;"></div>
        <p>Modelado arquitect√≥nico fotorrealista con iluminaci√≥n volum√©trica y texturas procedurales de alta calidad.</p>
        <p><strong>Software:</strong> Blender, Cycles Render</p>
        <p><strong>A√±o:</strong> 2024</p>
        <button class="close-popup" onclick="closePopup('popup-1')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<div class="popup-overlay" id="popup-2">
    <div class="popup-content">
        <h2>üë§ Dise√±o de Personajes</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px;"></div>
        <p>Creaci√≥n de personajes estilizados con rigging completo y animaciones cinem√°ticas.</p>
        <p><strong>Software:</strong> Maya, Substance Painter</p>
        <p><strong>A√±o:</strong> 2024</p>
        <button class="close-popup" onclick="closePopup('popup-2')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<div class="popup-overlay" id="popup-3">
    <div class="popup-content">
        <h2>üåç Entornos Fotorrealistas</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px;"></div>
        <p>Construcci√≥n de entornos naturales con vegetaci√≥n procedural y sistema de iluminaci√≥n global.</p>
        <p><strong>Software:</strong> Blender, Octane Render</p>
        <p><strong>A√±o:</strong> 2023</p>
        <button class="close-popup" onclick="closePopup('popup-3')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<div class="popup-overlay" id="popup-4">
    <div class="popup-content">
        <h2>‚ú® Motion Graphics</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius: 10px;"></div>
        <p>Animaciones abstractas y efectos visuales para contenido publicitario y redes sociales.</p>
        <p><strong>Software:</strong> Cinema 4D, After Effects</p>
        <p><strong>A√±o:</strong> 2024</p>
        <button class="close-popup" onclick="closePopup('popup-4')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<div class="popup-overlay" id="popup-5">
    <div class="popup-content">
        <h2>üèôÔ∏è Visualizaci√≥n Urbana</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); border-radius: 10px;"></div>
        <p>Renders arquitect√≥nicos para proyectos urbanos con integraci√≥n fotogr√°fica realista.</p>
        <p><strong>Software:</strong> 3ds Max, V-Ray</p>
        <p><strong>A√±o:</strong> 2023</p>
        <button class="close-popup" onclick="closePopup('popup-5')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<div class="popup-overlay" id="popup-6">
    <div class="popup-content">
        <h2>üé¨ Producci√≥n Audiovisual</h2>
        <div style="width: 100%; height: 250px; background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); border-radius: 10px;"></div>
        <p>Efectos especiales y composici√≥n digital para cortometrajes y producciones comerciales.</p>
        <p><strong>Software:</strong> Houdini, Nuke</p>
        <p><strong>A√±o:</strong> 2024</p>
        <button class="close-popup" onclick="closePopup('popup-6')">CONTINUAR EXPLORANDO</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    let gameStarted = false;
    let gameSpeed = 0;
    let skierRotation = 0;
    let skierTilt = 0;
    let discoveredWorks = new Set();
    let touchLeft = false;
    let touchRight = false;
    let gyroEnabled = false;

    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xe0f7ff, 50, 300);

    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    // Create snow mountain terrain
    function createSnowMountain() {
        const geometry = new THREE.PlaneGeometry(200, 400, 100, 200);
        const vertices = geometry.attributes.position.array;

        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            
            // Create slope going downhill
            let height = (y + 200) * 0.3;
            
            // Add bumps and moguls
            height += Math.sin(x * 0.2) * Math.cos(y * 0.15) * 3;
            height += Math.sin(x * 0.1) * Math.cos(y * 0.1) * 5;
            height += (Math.random() - 0.5) * 1.5;
            
            vertices[i + 2] = height;
        }

        geometry.computeVertexNormals();
        
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.9,
            metalness: 0.0,
        });

        const mountain = new THREE.Mesh(geometry, material);
        mountain.rotation.x = -Math.PI / 2;
        mountain.receiveShadow = true;
        mountain.castShadow = true;
        return mountain;
    }

    const mountain = createSnowMountain();
    scene.add(mountain);

    // Create low-poly skier
    function createSkier() {
        const skierGroup = new THREE.Group();

        // Body (main cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 6);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        skierGroup.add(body);

        // Head (sphere)
        const headGeometry = new THREE.SphereGeometry(0.4, 6, 6);
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.2;
        head.castShadow = true;
        skierGroup.add(head);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 4);
        const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.5, 0.3, 0);
        leftArm.rotation.z = Math.PI / 4;
        leftArm.castShadow = true;
        skierGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.5, 0.3, 0);
        rightArm.rotation.z = -Math.PI / 4;
        rightArm.castShadow = true;
        skierGroup.add(rightArm);

        // Skis
        const skiGeometry = new THREE.BoxGeometry(0.15, 0.1, 2);
        const skiMaterial = new THREE.MeshStandardMaterial({ color: 0x00d4ff });
        
        const leftSki = new THREE.Mesh(skiGeometry, skiMaterial);
        leftSki.position.set(-0.25, -1, 0.3);
        leftSki.castShadow = true;
        skierGroup.add(leftSki);

        const rightSki = new THREE.Mesh(skiGeometry, skiMaterial);
        rightSki.position.set(0.25, -1, 0.3);
        rightSki.castShadow = true;
        skierGroup.add(rightSki);

        // Ski poles
        const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 4);
        const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        
        const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
        leftPole.position.set(-0.7, -0.2, 0.5);
        leftPole.rotation.x = Math.PI / 6;
        leftPole.castShadow = true;
        skierGroup.add(leftPole);

        const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
        rightPole.position.set(0.7, -0.2, 0.5);
        rightPole.rotation.x = Math.PI / 6;
        rightPole.castShadow = true;
        skierGroup.add(rightPole);

        skierGroup.position.set(0, 10, 80);
        return skierGroup;
    }

    const skier = createSkier();
    scene.add(skier);

    // Create artwork displays (low-poly frames)
    const artworks = [];
    const artworkPositions = [
        { x: -15, z: 40, id: 1 },
        { x: 20, z: 10, id: 2 },
        { x: -25, z: -20, id: 3 },
        { x: 15, z: -50, id: 4 },
        { x: -18, z: -80, id: 5 },
        { x: 22, z: -110, id: 6 }
    ];

    artworkPositions.forEach(pos => {
        const artworkGroup = new THREE.Group();

        // Frame
        const frameGeometry = new THREE.BoxGeometry(6, 5, 0.3);
        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        frame.castShadow = true;
        artworkGroup.add(frame);

        // Canvas (gradient placeholder)
        const canvasGeometry = new THREE.PlaneGeometry(5, 4);
        const canvasMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00d4ff,
            emissive: 0x003366,
            emissiveIntensity: 0.3
        });
        const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
        canvas.position.z = 0.2;
        artworkGroup.add(canvas);

        // Floating animation
        artworkGroup.userData.floatOffset = Math.random() * Math.PI * 2;
        artworkGroup.userData.id = pos.id;

        // Get terrain height
        const terrainHeight = (pos.z + 200) * 0.3 + 5;
        
        artworkGroup.position.set(pos.x, terrainHeight, pos.z);
        artworkGroup.rotation.y = Math.PI;

        scene.add(artworkGroup);
        artworks.push(artworkGroup);
    });

    // Add pine trees (low-poly)
    function createTree(x, z) {
        const treeGroup = new THREE.Group();

        // Trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 6);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.castShadow = true;
        treeGroup.add(trunk);

        // Foliage layers
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x1a4d2e });
        
        for (let i = 0; i < 3; i++) {
            const foliageGeometry = new THREE.ConeGeometry(1.5 - i * 0.3, 2, 6);
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 2 + i * 1.2;
            foliage.castShadow = true;
            treeGroup.add(foliage);
        }

        const terrainHeight = (z + 200) * 0.3;
        treeGroup.position.set(x, terrainHeight + 1.5, z);
        
        return treeGroup;
    }

    // Add trees along the slope
    for (let i = 0; i < 50; i++) {
        const side = Math.random() > 0.5 ? 1 : -1;
        const x = side * (30 + Math.random() * 40);
        const z = -150 + Math.random() * 400;
        scene.add(createTree(x, z));
    }

    // Particles (snow)
    const particleGeometry = new THREE.BufferGeometry();
    const particleCount = 500;
    const particlePositions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount * 3; i += 3) {
        particlePositions[i] = (Math.random() - 0.5) * 150;
        particlePositions[i + 1] = Math.random() * 100;
        particlePositions[i + 2] = (Math.random() - 0.5) * 150 + skier.position.z;
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.8,
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // Camera setup
    camera.position.set(0, 15, 90);
    camera.lookAt(skier.position);

    // Touch controls
    document.getElementById('left-zone').addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchLeft = true;
    });

    document.getElementById('left-zone').addEventListener('touchend', (e) => {
        e.preventDefault();
        touchLeft = false;
    });

    document.getElementById('right-zone').addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchRight = true;
    });

    document.getElementById('right-zone').addEventListener('touchend', (e) => {
        e.preventDefault();
        touchRight = false;
    });

    // Gyroscope support
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (e) => {
            if (gameStarted && e.gamma !== null) {
                gyroEnabled = true;
                skierTilt = e.gamma / 90; // Normalize to -1 to 1
            }
        });
    }

    // Start button
    document.getElementById('start-button').addEventListener('click', () => {
        gameStarted = true;
        document.getElementById('start-button').style.display = 'none';
        document.getElementById('controls-info').style.display = 'block';
    });

    // Popup functions
    function showPopup(id) {
        document.getElementById(`popup-${id}`).style.display = 'flex';
        gameStarted = false;
    }

    function closePopup(popupId) {
        document.getElementById(popupId).style.display = 'none';
        gameStarted = true;
    }
    window.closePopup = closePopup;

    // Get terrain height at position
    function getTerrainHeight(x, z) {
        return (z + 200) * 0.3 + 
               Math.sin(x * 0.2) * Math.cos(z * 0.15) * 3 +
               Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
    }

    // Animation loop
    let lastTime = Date.now();

    function animate() {
        requestAnimationFrame(animate);

        const currentTime = Date.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        if (gameStarted) {
            // Increase speed (gravity effect)
            gameSpeed += 0.3 * deltaTime * 60;
            gameSpeed = Math.min(gameSpeed, 50);

            // Steering
            let steerInput = 0;
            if (touchLeft) steerInput -= 1;
            if (touchRight) steerInput += 1;
            if (gyroEnabled && Math.abs(skierTilt) > 0.1) {
                steerInput += skierTilt * 0.5;
            }

            skierRotation += steerInput * 0.05;
            skier.rotation.y = skierRotation;

            // Move skier forward
            const moveSpeed = gameSpeed * deltaTime;
            skier.position.x += Math.sin(skierRotation) * moveSpeed;
            skier.position.z -= Math.cos(skierRotation) * moveSpeed;

            // Terrain following
            const terrainHeight = getTerrainHeight(skier.position.x, skier.position.z);
            skier.position.y = terrainHeight + 2;

            // Tilt based on speed and turn
            skier.rotation.z = -steerInput * 0.3;
            skier.rotation.x = Math.min(gameSpeed / 100, 0.2);

            // Check artwork proximity
            artworks.forEach(artwork => {
                const distance = skier.position.distanceTo(artwork.position);
                if (distance < 8 && !discoveredWorks.has(artwork.userData.id)) {
                    discoveredWorks.add(artwork.userData.id);
                    showPopup(artwork.userData.id);
                    document.getElementById('works-value').textContent = 
                        `${discoveredWorks.size} / ${artworks.length}`;
                }

                // Floating animation
                artwork.position.y = getTerrainHeight(artwork.position.x, artwork.position.z) + 5 +
                                    Math.sin(Date.now() * 0.001 + artwork.userData.floatOffset) * 0.5;
                artwork.rotation.y += 0.01;
            });

            // Update speed display
            document.getElementById('speed-value').textContent = 
                `${Math.round(gameSpeed)} km/h`;

            // Camera follow
            const cameraOffset = new THREE.Vector3(
                Math.sin(skierRotation + Math.PI) * 15,
                12,
                Math.cos(skierRotation + Math.PI) * 15
            );
            
            camera.position.x += (skier.position.x + cameraOffset.x - camera.position.x) * 0.1;
            camera.position.y += (skier.position.y + cameraOffset.y - camera.position.y) * 0.1;
            camera.position.z += (skier.position.z + cameraOffset.z - camera.position.z) * 0.1;
            
            camera.lookAt(skier.position.x, skier.position.y, skier.position.z);

            // Update particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] -= gameSpeed * 0.1 * deltaTime;
                if (positions[i + 1] < -10) {
                    positions[i + 1] = 100;
                    positions[i] = (Math.random() - 0.5) * 150 + skier.position.x;
                    positions[i + 2] = (Math.random() - 0.5) * 150 + skier.position.z;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Check if reached bottom
            if (skier.position.z < -140) {
                gameStarted = false;
                document.getElementById('final-count').textContent = discoveredWorks.size;
                document.getElementById('game-over').style.display = 'block';
            }
        }

        renderer.render(scene, camera);
    }

    // Window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Hide loading
    setTimeout(() => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 500);
    }, 1500);

    animate();
</script>
